name: 🚀 Deploy Backend - Blue/Green Strategy

on:
  push:
    branches:
      - main
      # - staging
  workflow_dispatch:
  schedule:
    # Ejecutar limpieza semanal los domingos a las 2 AM UTC
    - cron: '0 2 * * 0'
env:
  #########################################
  #   DOCKER
  #########################################
  DOCKER_BUILDKIT: 1
  REGISTRY: docker.io
  DOCKER_HUB_USERNAME: ${{ vars.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}
  DOCKER_HUB_APP_IMAGE: ${{ vars.DOCKER_HUB_APP_IMAGE }}
  
  #########################################
  #   SSH
  #########################################
  SSH_USER_PASSWORD: ${{ secrets.SSH_USER_PASSWORD }}

  #########################################
  #   DATABASE
  #########################################
  DB_NAME: ${{ vars.DB_NAME }}
  DB_USERNAME: ${{ vars.DB_USERNAME }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  DB_CONTAINER_PORT: ${{ vars.DB_CONTAINER_PORT }}

  #########################################
  #   JWT
  #########################################
  JWT_SECRET: ${{ secrets.JWT_SECRET }}

  #########################################
  #   CLOUDINARY
  #########################################
  CLOUDINARY_CLOUD_NAME: ${{ vars.CLOUDINARY_CLOUD_NAME }}
  CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
  CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}

  #########################################
  #   MAIL
  #########################################
  MAIL_HOST: ${{ secrets.MAIL_HOST }}
  MAIL_PORT: ${{ secrets.MAIL_PORT }}
  MAIL_USER: ${{ secrets.MAIL_USER }}
  MAIL_PASS: ${{ secrets.MAIL_PASS }}
  MAIL_FROM: ${{ secrets.MAIL_FROM }}

  #########################################
  #   FRONTEND
  #########################################
  FRONTEND_URL: ${{ vars.FRONTEND_URL }}

  #########################################
  #   ENVIRONMENT
  #########################################
  BACKEND_CONTAINER_PORT_BLUE: ${{ vars.BACKEND_CONTAINER_PORT_BLUE }}
  BACKEND_CONTAINER_PORT_GREEN: ${{ vars.BACKEND_CONTAINER_PORT_GREEN }}

jobs:
  #########################################
  #   1. DETERMINE ENVIRONMENT
  #########################################
  determine-environment:
    name: 🎯 Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment_name: ${{ steps.determine-env.outputs.environment_name }}
      docker_image_tag: ${{ steps.determine-env.outputs.docker_image_tag }}
      should_deploy: ${{ steps.determine-env.outputs.should_deploy }}
    steps:
      - name: Determine Environment and Tag
        id: determine-env
        run: |
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment_name=production" >> $GITHUB_OUTPUT
            echo "docker_image_tag=prod" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "environment_name=staging" >> $GITHUB_OUTPUT
            echo "docker_image_tag=stag" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi

  #########################################
  #   2. RUN TESTS
  #########################################
  test:
    name: 🧪 Test & Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: latest

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Run Linter
        run: pnpm run lint

      - name: Run Tests
        run: pnpm run test

  #########################################
  #   3. BUILD & PUSH DOCKER IMAGE
  #########################################
  build-and-push:
    name: 🏗️ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [determine-environment, test]
    if: needs.determine-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.determine-environment.outputs.environment_name }}
    outputs:
      image_name: ${{ steps.image-info.outputs.image_name }}
      image_tag: ${{ steps.image-info.outputs.image_tag }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_PASSWORD }}
          
      - name: Generate Image Info
        id: image-info
        run: |
          IMAGE_NAME="${{ env.DOCKER_HUB_USERNAME }}/${{ env.DOCKER_HUB_APP_IMAGE }}"
          IMAGE_TAG="${{ needs.determine-environment.outputs.docker_image_tag }}-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          target: production
          push: true
          tags: |
            ${{ steps.image-info.outputs.image_name }}:${{ steps.image-info.outputs.image_tag }}
            ${{ steps.image-info.outputs.image_name }}:${{ needs.determine-environment.outputs.docker_image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: 🧹 Cleanup Build Cache (Local)
        if: always()
        run: |
          echo "🧹 Cleaning up local build artifacts..."
          
          # Limpiar cache de Docker BuildKit
          docker buildx prune -f
          
          # Limpiar imágenes temporales del build
          docker image prune -f
          
          # Mostrar espacio liberado
          echo "💾 Disk space after cleanup:"
          df -h /tmp
          
          echo "✅ Local cleanup completed!"

  #########################################
  #   4. BLUE/GREEN DEPLOYMENT
  #########################################
  deploy:
    name: 🚀 Deploy with Blue/Green Strategy
    runs-on: self-hosted
    needs: [determine-environment, build-and-push]
    environment: ${{ needs.determine-environment.outputs.environment_name }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Environment Variables
        run: |
          echo "Setting up environment variables for ${{ needs.determine-environment.outputs.environment_name }}"

      - name: 🗄️ Setup Database
        run: |
          echo "🗄️ Setting up PostgreSQL database..."
          
          # Crear red para la base de datos si no existe
          echo "🌐 Creating network for ${{ needs.determine-environment.outputs.environment_name }}..."
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker network create ${{ env.DOCKER_HUB_APP_IMAGE }}-${{ needs.determine-environment.outputs.environment_name }}-network || true
          
          # Verificar si la base de datos ya existe
          if echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker ps | grep -q "${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }}"; then
            echo "✅ PostgreSQL database already running"
          else
            echo "🚀 Starting PostgreSQL database..." 
            
            # Parar y remover contenedor de BD existente si hay alguno fallido
            echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker rm -f ${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }} || true
            
            # Crear volumen para persistencia de datos
            echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker volume create ${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }}-data || true
            
            # Ejecutar PostgreSQL
            echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker run -d \
              --name ${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }} \
              --network ${{ env.DOCKER_HUB_APP_IMAGE }}-${{ needs.determine-environment.outputs.environment_name }}-network \
              --restart unless-stopped \
              -p ${{ env.DB_CONTAINER_PORT }}:5432 \
              -e POSTGRES_DB=${{ env.DB_NAME }} \
              -e POSTGRES_USER=${{ env.DB_USERNAME }} \
              -e POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }} \
              -v ${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }}-data:/var/lib/postgresql/data \
              postgres:15-alpine
            
            echo "⏳ Waiting for PostgreSQL to be ready..."
            sleep 10
            
            # Verificar que PostgreSQL esté funcionando
            for i in {1..30}; do
              if echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker exec ${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }} pg_isready -U ${{ env.DB_USERNAME }} -d ${{ env.DB_NAME }} >/dev/null 2>&1; then
                echo "✅ PostgreSQL is ready!"
                break
              fi
              echo "Attempt $i/30: PostgreSQL not ready yet..."
              sleep 5
            done
          fi

      - name: Determine Port Strategy
        id: determine-port
        run: |
          echo "🔍 Detectando puerto activo actual..."
          
          # Función para verificar si un puerto está activo y saludable
          check_port_health() {
            local port=$1
            if echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker ps --format "table {{.Names}}\t{{.Ports}}" | grep -q ":${port}->"; then
              # Verificar que el puerto responda a health check
              if curl -f -s "http://localhost:${port}/health" > /dev/null 2>&1; then
                return 0
              fi
              return 0
            fi
            return 1
          }
          
          # Verificar estado de los puertos
          blue_healthy=false
          green_healthy=false
          
          if check_port_health ${{ env.BACKEND_CONTAINER_PORT_BLUE }}; then
            blue_healthy=true
            echo "🔵 Puerto BLUE (${{ env.BACKEND_CONTAINER_PORT_BLUE }}) está ACTIVO actualmente"
          else
            echo "⚪ Puerto BLUE (${{ env.BACKEND_CONTAINER_PORT_BLUE }}) está DISPONIBLE para el nuevo deploy"
          fi
          
          if check_port_health ${{ env.BACKEND_CONTAINER_PORT_GREEN }}; then
            green_healthy=true
            echo "🟢 Puerto GREEN (${{ env.BACKEND_CONTAINER_PORT_GREEN }}) está ACTIVO actualmente"
          else
            echo "⚪ Puerto GREEN (${{ env.BACKEND_CONTAINER_PORT_GREEN }}) está DISPONIBLE para el nuevo deploy"
          fi
          
          # Determinar configuración de despliegue
          if [ "$blue_healthy" = true ] && [ "$green_healthy" = false ]; then
            # Blue activo, desplegar en Green
            echo "🔄 Estrategia: Desplegar en GREEN (puerto ${{ env.BACKEND_CONTAINER_PORT_GREEN }}) mientras BLUE sigue activo"
            echo "active_port=${{ env.BACKEND_CONTAINER_PORT_BLUE }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.BACKEND_CONTAINER_PORT_GREEN }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-blue" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-green" >> $GITHUB_OUTPUT
          elif [ "$green_healthy" = true ] && [ "$blue_healthy" = false ]; then
            # Green activo, desplegar en Blue
            echo "🔄 Estrategia: Desplegar en BLUE (puerto ${{ env.BACKEND_CONTAINER_PORT_BLUE }}) mientras GREEN sigue activo"
            echo "active_port=${{ env.BACKEND_CONTAINER_PORT_GREEN }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.BACKEND_CONTAINER_PORT_BLUE }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-green" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-blue" >> $GITHUB_OUTPUT
          elif [ "$blue_healthy" = false ] && [ "$green_healthy" = false ]; then
            # Ninguno activo, usar Blue como default
            echo "🚀 Estrategia: Primer deploy - iniciando en GREEN (puerto ${{ env.BACKEND_CONTAINER_PORT_GREEN }})"
            echo "active_port=" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.BACKEND_CONTAINER_PORT_GREEN }}" >> $GITHUB_OUTPUT
            echo "active_container=" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-blue" >> $GITHUB_OUTPUT
          else
            # Ambos activos - estado inconsistente
            echo "⚠️ ADVERTENCIA: Ambos puertos están activos. Limpiando estado inconsistente..."
            echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker rm -f ${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-green || true
            echo "🔄 Estrategia: Desplegar en GREEN (puerto ${{ env.BACKEND_CONTAINER_PORT_GREEN }}) después de limpieza"
            echo "active_port=${{ env.BACKEND_CONTAINER_PORT_BLUE }}" >> $GITHUB_OUTPUT
            echo "new_port=${{ env.BACKEND_CONTAINER_PORT_GREEN }}" >> $GITHUB_OUTPUT
            echo "active_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-blue" >> $GITHUB_OUTPUT
            echo "new_container=${{ env.DOCKER_HUB_APP_IMAGE }}-backend-${{ needs.determine-environment.outputs.docker_image_tag }}-green" >> $GITHUB_OUTPUT
          fi
          
      - name: Pull New Docker Image
        run: |
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker pull ${{ needs.build-and-push.outputs.image_name }}:${{ needs.build-and-push.outputs.image_tag }}

      - name: Deploy New Instance
        run: |
          # Limpiar SOLO el contenedor del puerto destino (si hay alguno previo fallido)
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.new_container }} || true
          
          # Levantar la nueva instancia en el puerto libre (SIN TOCAR el contenedor activo)
          echo "🚀 Desplegando nueva instancia en puerto ${{ steps.determine-port.outputs.new_port }}..."
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker run -d \
            --name ${{ steps.determine-port.outputs.new_container }} \
            --network ${{ env.DOCKER_HUB_APP_IMAGE }}-${{ needs.determine-environment.outputs.environment_name }}-network \
            --restart unless-stopped \
            -p ${{ steps.determine-port.outputs.new_port }}:3000 \ 
            -e NODE_ENV=production \
            -e PORT=3000 \
            -e DB_HOST=${{ env.DOCKER_HUB_APP_IMAGE }}-db-${{ needs.determine-environment.outputs.environment_name }} \
            -e DB_PORT=5432 \
            -e DB_USERNAME=${{ env.DB_USERNAME }} \
            -e DB_PASSWORD=${{ env.DB_PASSWORD }} \
            -e DB_NAME=${{ env.DB_NAME }} \
            -e JWT_SECRET=${{ env.JWT_SECRET }} \
            -e CLOUDINARY_CLOUD_NAME=${{ env.CLOUDINARY_CLOUD_NAME }} \
            -e CLOUDINARY_API_KEY=${{ env.CLOUDINARY_API_KEY }} \
            -e CLOUDINARY_API_SECRET=${{ env.CLOUDINARY_API_SECRET }} \
            -e MAIL_HOST=${{ env.MAIL_HOST }} \
            -e MAIL_PORT=${{ env.MAIL_PORT }} \
            -e MAIL_USER=${{ env.MAIL_USER }} \
            -e MAIL_PASS=${{ env.MAIL_PASS }} \
            -e MAIL_FROM=${{ env.MAIL_FROM }} \
            -e FRONTEND_URL=${{ secrets.FRONTEND_URL }} \
            ${{ needs.build-and-push.outputs.image_name }}:${{ needs.build-and-push.outputs.image_tag }}
          
          echo "✅ Nueva instancia desplegada. Contenedor activo anterior sigue corriendo para zero-downtime"

      - name: 🔄 Run Database Migrations
        run: |
          echo "🔄 Running database migrations..."
          
          # Esperar a que el contenedor esté corriendo
          sleep 10
          
          # Ejecutar migraciones
          echo ${{ secrets.SSH_USER_PASSWORD }} | sudo -S docker exec ${{ steps.determine-port.outputs.new_container }} pnpm run migration:run:prod
          
          echo "✅ Database migrations completed"

      - name: 🌱 Run Database Seeds
        run: |
          echo "🌱 Running database seeds..."
          
          # Ejecutar seeds
          echo ${{ secrets.SSH_USER_PASSWORD }} | sudo -S docker exec ${{ steps.determine-port.outputs.new_container }} pnpm run seed:prod
          
          echo "✅ Database seeds completed"

      - name: Wait for New Instance Health Check
        run: |
          echo "🏥 Esperando que la nueva instancia esté saludable..."
          max_attempts=30
          attempt=1
          healthy=false
          
          while [ $attempt -le $max_attempts ]; do
            echo "⏳ Intento $attempt/$max_attempts - Verificando health check..."
            
            # Verificar health check de la aplicación
            if curl -f -s http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "✅ Health check de aplicación: OK"
              
              # Verificar que el contenedor esté realmente saludable via Docker
              container_health=$(echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker inspect ${{ steps.determine-port.outputs.new_container }} --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")
              
              if [ "$container_health" = "healthy" ] || [ "$container_health" = "no-healthcheck" ]; then
                echo "✅ Container health: $container_health"
                
                # Verificar que responda correctamente múltiples veces
                success_count=0
                for i in {1..5}; do
                  if curl -f -s http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
                    success_count=$((success_count + 1))
                  fi
                  sleep 1
                done
                
                if [ $success_count -ge 4 ]; then
                  echo "✅ Nueva instancia está consistentemente saludable en puerto ${{ steps.determine-port.outputs.new_port }}"
                  healthy=true
                  break
                else
                  echo "⚠️ Respuestas inconsistentes ($success_count/5), continuando..."
                fi
              else
                echo "⚠️ Container health: $container_health"
              fi
            else
              echo "❌ Health check falló"
            fi
            
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ "$healthy" = false ]; then
            echo "❌ La nueva instancia no pasó el health check después de $max_attempts intentos"
            echo "🔄 Iniciando rollback automático..."
            
            # Cleanup de la nueva instancia fallida
            echo ${{ secrets.SSH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.new_container }} || true
            
            exit 1
          fi

      - name: Verify New Instance is Ready
        run: |
          echo "Verificando que la nueva instancia esté lista para recibir tráfico..."
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            # Verificar SOLO la nueva instancia directamente (no a través de Nginx)
            if curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "✅ Nueva instancia está lista en puerto ${{ steps.determine-port.outputs.new_port }}"
              echo "ℹ️ Nginx detectará automáticamente el cambio cuando se detenga la instancia anterior"
              break
            fi
            echo "⏳ Intento $attempt/$max_attempts - Verificando nueva instancia..."
            echo "   - Puerto ${{ steps.determine-port.outputs.new_port }}: $(curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1 && echo "OK" || echo "FAIL")"
            sleep 5
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "❌ La nueva instancia no está sirviendo tráfico correctamente"
            exit 1
          fi

      - name: Stop Old Instance
        run: |
          # Detener la instancia anterior SOLO después de confirmar que la nueva funciona correctamente
          if [ -n "${{ steps.determine-port.outputs.active_container }}" ]; then
            echo "🔄 Blue-Green Switch: Deteniendo instancia anterior ahora que la nueva está funcionando..."
            echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker rm -f ${{ steps.determine-port.outputs.active_container }} || true
            echo "✅ Zero-downtime completado: ${{ steps.determine-port.outputs.active_container }} → ${{ steps.determine-port.outputs.new_container }}"
          else
            echo "ℹ️ Primer deployment - no había instancia anterior que detener"
          fi

      - name: Verify Nginx is Serving New Instance
        run: |
          echo "🔍 Verificando que Nginx esté sirviendo la nueva instancia..."
          max_attempts=10
          attempt=1
          
          # Dar tiempo a Nginx para detectar que la instancia anterior se detuvo
          sleep 5
          
          while [ $attempt -le $max_attempts ]; do
            # Verificar que Nginx esté sirviendo la nueva instancia correctamente
            if curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1; then
              echo "✅ Nginx está sirviendo correctamente la nueva instancia"
              echo "🎯 Tráfico fluyendo: puerto 80 → puerto ${{ steps.determine-port.outputs.new_port }}"
              break
            fi
            echo "⏳ Intento $attempt/$max_attempts - Esperando que Nginx detecte el cambio..."
            echo "   - Verificando a través de Nginx (puerto 80): $(curl -f http://localhost:${{ steps.determine-port.outputs.new_port }}/health > /dev/null 2>&1 && echo "OK" || echo "FAIL")"
            sleep 3
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "❌ Nginx no está sirviendo correctamente a través del puerto 80"
            echo "🔧 Posible solución: verificar configuración de Nginx"
            exit 1
          fi

      - name: Deployment Summary
        run: |
          echo "🎉 Blue-Green Deployment Completado Exitosamente!"
          echo "📊 Resumen del despliegue:"
          echo "   - Puerto activo: ${{ steps.determine-port.outputs.new_port }}"
          echo "   - Contenedor activo: ${{ steps.determine-port.outputs.new_container }}"
          echo "   - Imagen: ${{ needs.build-and-push.outputs.image_name }}:${{ needs.build-and-push.outputs.image_tag }}"
          echo "   - Nginx: Sistema (no contenedor)"
          
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S systemctl status nginx --no-pager -l

      - name: Prune Docker Images unused
        run: |
          echo ${{ env.SSH_USER_PASSWORD }} | sudo -S docker image prune -f

      - name: 🧹 Cleanup Old Images & Containers
        run: |
          echo "🧹 Starting cleanup process..."
          
          # 1. Limpiar contenedores detenidos
          echo "🗑️ Removing stopped containers..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker container prune -f
          
          # 2. Limpiar imágenes huérfanas (sin tag)
          echo "🗑️ Removing dangling images..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker image prune -f
          
          # 3. Limpiar imágenes antiguas de nuestro proyecto (más de 7 días)
          echo "🗑️ Removing old project images (older than 7 days)..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker images ${{ needs.build-and-push.outputs.image_name }} --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            tail -n +2 | \
            awk -v cutoff="$(date -d '7 days ago' '+%Y-%m-%d')" '$2 < cutoff {print $1}' | \
            xargs -r echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker rmi || true
          
          # 4. Mantener solo las últimas 5 versiones específicas (por tag de commit)
          echo "📊 Keeping only last 5 specific versions..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker images ${{ needs.build-and-push.outputs.image_name }} --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep -E 'prod-[0-9]{8}-[0-9]{6}-[a-f0-9]{7}$' | \
            tail -n +2 | \
            sort -k2 -r | \
            tail -n +6 | \
            awk '{print $1}' | \
            xargs -r echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker rmi || true
          
          # 5. Limpiar volúmenes no utilizados
          echo "🗑️ Removing unused volumes..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker volume prune -f
          
          # 6. Limpiar redes no utilizadas
          echo "🗑️ Removing unused networks..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker network prune -f
          
          # 7. Limpiar cache de build
          echo "🗑️ Removing build cache..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker builder prune -f
          
          # 8. Mostrar estado final
          echo "📊 Final image status:"
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker images ${{ needs.build-and-push.outputs.image_name }} --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
          
          echo "✅ Cleanup completed successfully!"

      - name: Health Check Final
        run: |
          # Verificar que el servicio esté respondiendo correctamente
          sleep 30
          for i in {1..5}; do
            if curl -f http://localhost:3001/health; then
              echo "✅ Final health check passed!"
              break
            fi
            echo "Attempt $i/5: Service not responding..."
            sleep 10
          done

  #########################################
  #   5. WEEKLY CLEANUP (Scheduled)
  #########################################
  weekly-cleanup:
    name: 🧹 Weekly System Cleanup
    runs-on: self-hosted
    if: github.event_name == 'schedule'
    steps:
      - name: 🧹 Deep System Cleanup
        run: |
          echo "🧹 Starting weekly deep cleanup..."
          
          # 1. Limpiar TODOS los contenedores detenidos
          echo "🗑️ Removing all stopped containers..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker container prune -f 
          
          # 2. Limpiar TODAS las imágenes huérfanas
          echo "🗑️ Removing all dangling images..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker image prune -a -f
          
          # 3. Limpiar imágenes antiguas (más de 14 días)
          echo "🗑️ Removing images older than 14 days..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            tail -n +2 | \
            awk -v cutoff="$(date -d '14 days ago' '+%Y-%m-%d')" '$2 < cutoff {print $1}' | \
            xargs -r echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker rmi || true
          
          # 4. Limpiar volúmenes no utilizados
          echo "🗑️ Removing unused volumes..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker volume prune -f
          
          # 5. Limpiar redes no utilizadas
          echo "🗑️ Removing unused networks..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker network prune -f
          
          # 6. Limpiar cache de build
          echo "🗑️ Removing build cache..."
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker builder prune -a -f
          
          # 7. Mostrar estadísticas finales
          echo "📊 System status after cleanup:"
          echo "💾 Disk usage:"
          df -h
          echo "🐳 Docker images:"
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"
          echo "📦 Docker containers:"
          echo "${{ env.SSH_USER_PASSWORD }}" | sudo -S docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
          
          echo "✅ Weekly cleanup completed successfully!"

  #########################################
  #   6. NOTIFICATION
  #########################################
  notify:
    name: 📢 Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]
    if: always() && github.event_name != 'schedule'
    steps:
      - name: Notify Success
        if: needs.deploy.result == 'success'
        run: |
          echo "✅ Deployment to ${{ needs.determine-environment.outputs.environment_name }} was successful!"
          # Aquí puedes agregar notificaciones a Slack, Discord, etc.
          
      - name: Notify Failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "❌ Deployment to ${{ needs.determine-environment.outputs.environment_name }} failed!"
          # Aquí puedes agregar notificaciones de error
